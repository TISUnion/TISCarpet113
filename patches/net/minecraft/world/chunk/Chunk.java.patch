--- a/net/minecraft/world/chunk/Chunk.java
+++ b/net/minecraft/world/chunk/Chunk.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.chunk;
 
+import carpet.settings.CarpetSettings;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
@@ -55,6 +56,10 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+//TISCM: add chunk debug
+import carpet.logging.LoggerRegistry;
+import carpet.logging.logHelpers.ChunkLogHelper;
+
 public class Chunk implements IChunk
 {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -489,9 +494,16 @@
         }
     }
 
+    // [CM] wrapper to add no update flag
     @Nullable
     public IBlockState setBlockState(BlockPos pos, IBlockState state, boolean isMoving)
     {
+        return setBlockState(pos, state, isMoving, false);
+    }
+
+    @Nullable
+    public IBlockState setBlockState(BlockPos pos, IBlockState state, boolean isMoving, boolean skipUpdates)
+    {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
@@ -568,14 +580,26 @@
                     }
                 }
 
-                if (!this.world.isRemote)
+                //if (!this.world.isRemote) // CM added support for placing without updates
+                if (!skipUpdates && !this.world.isRemote)
                 {
                     state.onBlockAdded(this.world, pos, iblockstate);
                 }
 
                 if (block instanceof ITileEntityProvider)
                 {
-                    TileEntity tileentity1 = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
+                    // [CM] Movable TE's CARPET-DeadlyMC
+                    TileEntity tileentity1; // = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
+    
+                    // [CM] Movable TE's CARPET-DeadlyMC
+                    if(CarpetSettings.movableTileEntities)
+                    {  //this.getTileEntity(...) doesn't check pending TileEntities
+                        tileentity1 = this.world.getTileEntity(pos);
+                    }
+                    else
+                    { // vanilla
+                        tileentity1 = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
+                    }
 
                     if (tileentity1 == null)
                     {
@@ -894,6 +918,19 @@
                 return !(p_212383_0_ instanceof EntityPlayer);
             }));
         }
+
+        //TISCM: chunk debug
+        if (LoggerRegistry.__chunkdebug){
+            if (this.world.dimension.isNether()) {
+                this.world.chunkLogHelper.onChunkNewState("Nether", this.x, this.z, "l Loaded");
+            }
+            else if (this.world.dimension.hasSkyLight()){
+                this.world.chunkLogHelper.onChunkNewState("Overworld", this.x, this.z, "l Loaded");
+            }
+            else{
+                this.world.chunkLogHelper.onChunkNewState("End", this.x, this.z, "l Loaded");
+            }
+        }
     }
 
     public void onUnload()
@@ -909,6 +946,19 @@
         {
             this.world.unloadEntities(classinheritancemultimap);
         }
+
+        //TISCM: chunk debug
+        if (LoggerRegistry.__chunkdebug){
+            if (this.world.dimension.isNether()) {
+                this.world.chunkLogHelper.onChunkNewState("Nether", this.x, this.z, "r Unloaded");
+            }
+            else if (this.world.dimension.hasSkyLight()){
+                this.world.chunkLogHelper.onChunkNewState("Overworld", this.x, this.z, "r Unloaded");
+            }
+            else {
+                this.world.chunkLogHelper.onChunkNewState("End", this.x, this.z, "r Unloaded");
+            }
+        }
     }
 
     public void markDirty()
